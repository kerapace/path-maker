/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./grid.js":
/*!*****************!*\
  !*** ./grid.js ***!
  \*****************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {Arc, Line, Freehand} = __webpack_require__(/*! ./shapes */ \"./shapes.js\");\n\nfunction createCells(width, height) {\n  const cells = [];\n  const len = width*height;\n    for(let i = 0; i < len; i++) {\n      cells.push({\n        i,\n        x: i % width,\n        y: Math.floor(i / width),\n      });\n    }\n  return cells;\n}\n\nfunction createBounds(grid) {\n  return {\n    xMin: 0,\n    yMin: 0,\n    xMax: grid.cellSize * grid.width - grid.canvas.width,\n    yMax: grid.cellSize * grid.height - grid.canvas.height,\n  };\n}\n\nfunction defineGrid(canvas) {\n  grid = {};\n  grid.canvas = canvas;\n  grid.cellSize = 20;\n  grid.width = 100;\n  grid.height = 100;\n  grid.xOffset = grid.width*grid.cellSize/2;\n  grid.yOffset = grid.height*grid.cellSize/2;\n  grid.cells = createCells(grid.width,grid.height);\n  grid.bounds = createBounds(grid);\n  return grid;\n}\n\n\nclass GridAPI {\n  constructor(canvas,storage) {\n    this.grid = defineGrid(canvas);\n    this.ctx = canvas.getContext('2d');\n    this.shapes = [];\n    this.undoneShapes = [];\n    this.position = {x: null, y: null};\n    this.hoverPosition = {x: null, y: null};\n    this.active = false;\n    this.tool = \"move\";\n    this.currShape = null;\n    this.snapToGrid = 20;\n    this.isSnappedToGrid = true;\n    this.storage = storage;\n    setInterval(() => {\n      this.ctx.clearRect(0,0,canvas.width,canvas.height);\n      this.drawGrid();\n      this.ctx.strokeStyle = \"#000000\";\n      this.shapes.forEach(shape => shape.draw(this.ctx,this.grid));\n      if(this.currShape !== null) {this.currShape.draw(this.ctx,this.grid,this.position);}\n      if(this.isSnappedToGrid && (this.tool === \"arc\" || this.tool === \"line\") && !this.active) {\n        this.ctx.fillStyle = \"#fcad03\";\n        this.ctx.beginPath();\n        this.ctx.arc(this.hoverPosition.x-this.grid.xOffset,this.hoverPosition.y-this.grid.yOffset,2,0,2*Math.PI);\n        this.ctx.fill();\n      }\n    },30);\n  }\n\n  moveView(deltaX, deltaY) {\n    this.grid.xOffset += deltaX;\n    this.grid.yOffset += deltaY;\n    this.applyBounds();\n  }\n\n  drawGrid() {\n    this.ctx.strokeStyle = \"#5bd5e3\";\n    const grid = this.grid;\n    grid.cells.forEach(cell => \n      {\n        if(cell.x * (grid.cellSize + 1) < grid.xOffset ||\n          cell.y * (grid.cellSize + 1) < grid.yOffset || \n          cell.x * grid.cellSize > grid.xOffset + grid.canvas.width ||\n          cell.y * grid.cellSize > grid.yOffset + grid.canvas.height) {\n          return;\n        }\n        else {\n          this.ctx.strokeRect(cell.x*grid.cellSize-grid.xOffset,cell.y*grid.cellSize-grid.yOffset,grid.cellSize,grid.cellSize)\n        }\n      }\n    );\n  }\n\n  applyBounds() {\n    this.grid.bounds || (this.grid.bounds = createBounds(this.grid));\n    this.grid.xOffset = this.grid.xOffset < this.grid.bounds.xMin ? this.grid.bounds.xMin : this.grid.xOffset;\n    this.grid.yOffset = this.grid.yOffset < this.grid.bounds.yMin ? this.grid.bounds.yMin : this.grid.yOffset;\n    this.grid.xOffset = this.grid.xOffset > this.grid.bounds.xMax ? this.grid.bounds.xMax : this.grid.xOffset;\n    this.grid.yOffset = this.grid.yOffset > this.grid.bounds.yMax ? this.grid.bounds.yMax : this.grid.yOffset;\n  }\n\n  updatePosition(e) {\n    if(this.isSnappedToGrid === false || this.tool === \"freehand\" || this.tool === \"move\") {\n      this.position = {x: this.grid.xOffset+e.offsetX, y: this.grid.yOffset+e.offsetY};\n    } else {\n      this.position = {\n        x: this.snapToGrid*Math.round((this.grid.xOffset+e.offsetX)/this.snapToGrid),\n        y: this.snapToGrid*Math.round((this.grid.yOffset+e.offsetY)/this.snapToGrid),\n      }\n    }\n  }\n\n  updateHoverPosition(e) {\n    if(this.isSnappedToGrid) {\n      this.hoverPosition = {\n        x: this.snapToGrid*Math.round((this.grid.xOffset+e.offsetX)/this.snapToGrid),\n        y: this.snapToGrid*Math.round((this.grid.yOffset+e.offsetY)/this.snapToGrid),\n      }\n    }\n  }\n\n  discardShape() {\n    this.currShape = null;\n    this.active = false;\n  }\n\n  undoShape() {\n    if(this.currShape !== null) {\n      this.currShape = null;\n      return;\n    }\n    if(this.shapes.length === 0) {return;}\n    const shape = this.shapes.pop();\n    this.undoneShapes.push(shape);\n    this.updateSave();\n  }\n\n  redoShape() {\n    if(this.undoneShapes.length === 0) {return;}\n    const shape = this.undoneShapes.pop();\n    this.shapes.push(shape);\n    this.updateSave();\n  }\n\n  resetShapes() {\n    this.shapes = [];\n    this.undoneShapes = [];\n    this.currShape = null;\n    this.active = false;\n    this.grid.xOffset = grid.width*grid.cellSize/2;\n    this.grid.yOffset = grid.height*grid.cellSize/2;\n    this.updateSave();\n  }\n\n  completeShape() {\n    this.shapes.push(this.currShape);\n    this.undoneShapes = [];\n    this.currShape = null;\n    this.active = false;\n    this.updateSave();\n  }\n\n  updateSave() {\n    this.storage.shapes = this.serializeShapes();\n  }\n\n  serializeShapes() {\n    return JSON.stringify({shapes: this.shapes.map(shape => Object.assign(shape,{class: shape.constructor.name}))});\n  }\n\n  loadShapesFromJSON(json) {\n    this.shapes = JSON.parse(json).shapes.map(shapeData => {\n      let ShapeType = Object;\n      switch (shapeData.class) {\n        case \"Line\":\n          ShapeType = Line;\n          break;\n        case \"Arc\":\n          ShapeType = Arc;\n          break;\n        case \"Freehand\":\n          ShapeType = Freehand;\n          break;\n        default:\n          throw new Error('Invalid JSON');\n      }\n      delete shapeData.class;\n      return Object.assign(new ShapeType,shapeData);\n    });\n  }\n}\n\nmodule.exports = GridAPI;\n\n//# sourceURL=webpack://path-maker/./grid.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const GridAPI = __webpack_require__(/*! ./grid.js */ \"./grid.js\");\nconst {Line, Arc, Freehand} = __webpack_require__(/*! ./shapes.js */ \"./shapes.js\");\nconst canvas = document.getElementById(\"map-canvas\");\nconst downloadLink = document.querySelector(\".download-link\");\nconst storage = window.localStorage;\nconst storageProxy = new Proxy({}, {\n  set: (obj, key, value) => {\n    storage.setItem(key,value);\n    if(key === \"shapes\") {\n      const json = [value];\n      const blob = new Blob(json, {type: 'text/plain;charset=utf-8'});\n      const oldObjectURL = downloadLink.href;\n      downloadLink.href = URL.createObjectURL(blob);\n      URL.revokeObjectURL(oldObjectURL);\n    }\n    return value;\n  },\n  get: (obj, prop) => {\n    return storage.getItem(prop);\n  }\n});\nconst gridAPI = new GridAPI(canvas,storageProxy);\nconst buttons = document.querySelectorAll(\".draw-button\");\nbuttons.forEach(button => button.addEventListener(\"click\",(e) => {gridAPI.tool = e.target.dataset.tool}));\ngridAPI.drawGrid();\nlet shapes = storageProxy.shapes;\nif (shapes) {\n  gridAPI.loadShapesFromJSON(shapes);\n}\nconst initialJSON = [shapes];\nconst initialBlob = new Blob(initialJSON, {type: 'text/plain;charset=utf-8'});\ndownloadLink.href = URL.createObjectURL(initialBlob);\n\nconst importJSON = document.getElementById(\"import-json\");\n\nimportJSON.addEventListener(\"change\", (e) => {\n  const prevShapes = gridAPI.shapes;\n  const file = e.target.files[0];\n  const reader = new FileReader();\n  reader.readAsText(file);\n  reader.onload = () => {\n    try {gridAPI.loadShapesFromJSON(reader.result);}\n    catch (e) {gridAPI.shapes = prevShapes;}\n  }\n  reader.onerror = () => {\n    window.alert(reader.error);\n  }\n  e.target.value = \"\";\n});\n\n\n\nconst viewBox = document.querySelector(\".viewbox\");\nconst modalButton = document.querySelector(\".infobox\");\nconst modalBackground = document.querySelector(\".modal-background\");\nconst snapToGridOptions = document.querySelector(\".snap-options-dropdown\");\nconst undoButton = document.querySelector(\".undo-button\");\nconst redoButton = document.querySelector(\".redo-button\");\nconst resetButton = document.querySelector(\".reset-button\");\nconst uploadButton = document.querySelector(\".upload-button\");\n\nuploadButton.addEventListener(\"click\", () => {\n  importJSON.click();\n})\n\n\nsnapToGridOptions.addEventListener(\"click\", (e) => {\n    const stg = e.target.dataset.stg;\n    if(stg === \"false\") {\n      gridAPI.isSnappedToGrid = false;\n    }\n    else {\n      gridAPI.isSnappedToGrid = true;\n      gridAPI.snapToGrid = stg;\n    }\n  }\n);\n\n[modalButton,modalBackground].forEach(el => \n  el.addEventListener(\"click\", (e) => {\n    if (e.target === e.currentTarget) {\n      modalBackground.classList.toggle(\"visible\");\n      viewBox.classList.toggle(\"blurred\");\n    }\n  })\n);\n\nundoButton.addEventListener(\"click\", (e) => gridAPI.undoShape());\nredoButton.addEventListener(\"click\", (e) => gridAPI.redoShape());\nresetButton.addEventListener(\"click\", (e) => gridAPI.resetShapes());\n\ncanvas.addEventListener(\"mousedown\", (e) => {\n  switch(gridAPI.tool) {\n    case \"move\":\n      gridAPI.active = true;\n      gridAPI.updatePosition(e);\n      break;\n    case \"freehand\":\n      gridAPI.active = true;\n      gridAPI.updatePosition(e);\n      gridAPI.currShape = new Freehand([[gridAPI.position.x,gridAPI.position.y]]);\n      break;\n  }\n});\n\ncanvas.addEventListener(\"click\", (e) => {\n  switch(gridAPI.tool) {\n    case \"line\":\n      if(gridAPI.currShape) {\n        gridAPI.updatePosition(e);\n        gridAPI.currShape.x2 = gridAPI.position.x;\n        gridAPI.currShape.y2 = gridAPI.position.y;\n        gridAPI.completeShape();\n      }\n      else {\n        gridAPI.updatePosition(e);\n        gridAPI.currShape = new Line(gridAPI.position.x,gridAPI.position.y);\n        gridAPI.active = true;\n      }\n      break;\n    case \"arc\":\n      if (gridAPI.currShape) {\n        if (gridAPI.currShape.rad === undefined) {\n          gridAPI.updatePosition(e);\n          gridAPI.currShape.rad = Math.sqrt((gridAPI.position.x-gridAPI.currShape.x)**2 + (gridAPI.position.y-gridAPI.currShape.y)**2);\n          gridAPI.currShape.startAngle = Math.atan2(gridAPI.position.y-gridAPI.currShape.y,gridAPI.position.x-gridAPI.currShape.x);\n          gridAPI.isSnappedToGrid = false;\n        }\n        else {\n          gridAPI.updatePosition(e);\n          const angle = Math.atan2(gridAPI.position.y-gridAPI.currShape.y,gridAPI.position.x-gridAPI.currShape.x);\n          gridAPI.currShape.endAngle = Math.abs(angle - gridAPI.currShape.startAngle) < 0.05 ? gridAPI.currShape.startAngle + Math.PI * 2 : angle \n          gridAPI.completeShape();\n          gridAPI.isSnappedToGrid = true;\n        }\n      }\n      else {\n        gridAPI.updatePosition(e);\n        gridAPI.currShape = new Arc(gridAPI.position.x,gridAPI.position.y);\n        gridAPI.active = true;\n      }\n    }\n});\n\ndocument.addEventListener(\"mousemove\", (e) => {\n  if(!gridAPI.active) {\n    gridAPI.updateHoverPosition(e);\n    return;\n  }\n  switch(gridAPI.tool) {\n    case \"move\":\n      gridAPI.moveView(gridAPI.position.x-gridAPI.grid.xOffset-e.offsetX,gridAPI.position.y-gridAPI.grid.yOffset-e.offsetY);\n      gridAPI.updatePosition(e);\n      break;\n    case \"freehand\":\n      gridAPI.updatePosition(e);\n      if (e.target === canvas) {gridAPI.currShape.points.push([gridAPI.position.x,gridAPI.position.y]);}\n      break;\n    case \"arc\":\n    case \"line\":\n      if(gridAPI.currShape) {\n        gridAPI.updatePosition(e);\n      }\n      break;\n  }\n});\n\ncanvas.addEventListener(\"mouseup\", (e) => {\n  if(!gridAPI.active) {return;}\n  switch(gridAPI.tool) {\n    case \"move\":\n      gridAPI.moveView(gridAPI.position.x-e.offsetX-gridAPI.grid.xOffset,gridAPI.position.y-e.offsetY-gridAPI.grid.yOffset);\n      gridAPI.active = false;\n      break;\n    case \"freehand\":\n      gridAPI.updatePosition(e);\n      gridAPI.currShape.points.push([gridAPI.position.x,gridAPI.position.y]);\n      gridAPI.completeShape();\n      gridAPI.active = false;\n  }\n});\n\ncanvas.addEventListener(\"mouseleave\",(e) => {\n\n});\n\ncanvas.addEventListener(\"mouseenter\",(e) => {\n  if(!gridAPI.active) {return;}\n  switch(gridAPI.tool) {\n    case \"freehand\":\n      gridAPI.updatePosition(e);\n      gridAPI.currShape.points.push([gridAPI.position.x,gridAPI.position.y]);\n  }\n});\n\n//# sourceURL=webpack://path-maker/./index.js?");

/***/ }),

/***/ "./shapes.js":
/*!*******************!*\
  !*** ./shapes.js ***!
  \*******************/
/***/ ((module) => {

eval("class Arc {\n  constructor(x,y,rad,startAngle,endAngle) {\n    Object.assign(this,{x,y,rad,startAngle,endAngle});\n  }\n\n  bounds() {\n    return {\n      minX: this.x-this.rad,\n      minY: this.y-this.rad,\n      maxX: this.x+this.rad,\n      maxY: this.y+this.rad\n    };\n  }\n\n  draw(ctx,grid,pos) {\n    const rad = this.rad === undefined ? Math.sqrt((pos.x-this.x)**2 + (pos.y-this.y)**2) : this.rad;\n    const startAngle = this.startAngle === undefined ? Math.atan2(pos.y-this.y,pos.x-this.x) : this.startAngle;\n    let endAngle = 0;\n    if(this.endAngle !== undefined) {\n      endAngle = this.endAngle\n    }\n    else if(this.startAngle === undefined) {\n      endAngle = startAngle + 2 * Math.PI;\n    }\n    else {\n      let angle = (Math.atan2(pos.y-this.y,pos.x-this.x) - startAngle) % (2 * Math.PI) + startAngle;\n      endAngle = rad * Math.abs(angle - startAngle) < 2 ? startAngle + 2*Math.PI : angle\n    }\n    ctx.beginPath();\n    rad === 0 ? ctx.fillRect(this.x-grid.xOffset,this.y-grid.yOffset,1,1) : ctx.arc(this.x-grid.xOffset,this.y-grid.yOffset,rad,startAngle,endAngle);\n    ctx.stroke();\n  }\n}\n\nclass Line {\n  constructor(x1,y1,x2,y2) {\n    Object.assign(this,{x1,y1,x2,y2});\n  }\n\n  bounds() {\n    return {\n      minX: Math.min(this.x1,this.x2),\n      minY: Math.min(this.y1,this.y2),\n      maxX: Math.max(this.x1,this.x2),\n      maxY: Math.max(this.y1,this.y2)\n    };\n  }\n\n  draw(ctx,grid,pos) {\n    ctx.beginPath();\n    ctx.moveTo(this.x1-grid.xOffset,this.y1-grid.yOffset);\n    const [x2, y2] = [this.x2,this.y2].some(a => a === undefined) ? [pos.x, pos.y] : [this.x2,this.y2];\n    ctx.lineTo(x2-grid.xOffset,y2-grid.yOffset);\n    ctx.stroke();\n  }\n}\n\nclass Freehand {\n  constructor(points) {\n    this.points = points;\n  }\n\n  bounds() {\n    if(this._bounds !== undefined) {return this._bounds;}\n    xcoords = points.map(point => point[0]);\n    ycoords = points.map(point => point[1]);\n    this._bounds = {\n      minX: Math.min(...xcoords),\n      minY: Math.min(...ycoords),\n      maxX: Math.max(...xcoords),\n      maxY: Math.max(...ycoords)\n    };\n    return this._bounds;\n  }\n\n  draw(ctx,grid) {\n    ctx.beginPath();\n    this.points.forEach(point => {\n      ctx.lineTo(point[0]-grid.xOffset,point[1]-grid.yOffset);\n    });\n    ctx.stroke();\n  }\n}\n\nmodule.exports = {\n  Line,\n  Arc,\n  Freehand,\n}\n\n//# sourceURL=webpack://path-maker/./shapes.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./index.js");
/******/ 	
/******/ })()
;